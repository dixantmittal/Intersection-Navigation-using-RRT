# Intersection Navigation using RRT
Solving Intersection Navigation for a car using Rapidly Exploring Random Tree (RRT) algorithm under dynamic constraints.

Taking the ideas from [Hsu02], I implemented the algorithm in a similar way. Let’s start with describing the state space first. The state space,, of our autonomous car , composes of  where  is the position of  in its lane,  is the velocity of at position  and  is the timestep at which it reached . At any timestep , we choose a value for acceleration, , and integrate its value with given  (which is inverse of frequency  in our case) to get velocity change for timestep  by equation:
dv=a*dt
The algorithm first selects a node, , to expand via random sampling from given range (note: range changes as we reach a goal path to further concentrate on finding a path with shorter total time) and exploring in the free space (like we do in RRT). After  has been selected, it selects a random value of acceleration to apply on the state of  with some bias to direct the graph more towards final position. As  is given to be 0.1 second, so, we calculate the new state, , by integrating value of acceleration and . The trajectory from  to , is then checked for collisions. If trajectory is collision free,  is added to the graph and corresponding control is stored with edge . After the limit on number of samples is reached, we get a graph with multiple trajectories from initial position to goal position. We then select the trajectory which took the shortest time and execute it.

Design choices:
⇒	Selection of node to expand: One of the key element was to design . Uniform selection of nodes in the graph would have resulted in overloading of an area with many nodes and not much free area would have been explored. So, some kind of bias was needed to direct the exploration away from the current density. We could use EST like weighted sampling by assigning each node with a weight inversely proportional to its density as done in [Hsu02]. But I found that calculating spatial density for each node was computational expensive. Alternatively, we could have divided nodes into bins and then choose a bin uniformly and then pick a node from selected bin. It would have also resulted in better exploration than standard uniform selection of nodes. Another way was to give weight inversely proportional to degree of the node, but this resulted in requiring exponential number of nodes to reach target position (very bad). I found implementing RRT style selection of a graph node easy and not much computationally expensive. I controlled the range of sampling of random point (by controlling the value of ) to direct the graph to a particular region of interest. Particularly, once we find a path from initial to final position, we want to focus the scope of expansion to nodes which occurred prior to time taken by final position to get a better path taking lesser time.
⇒	Checking collision:  was also important piece of the algorithm. To check for collision, I used the approach taught in Lecture 1, in which we reduce our robot to point object and increase the size of obstacles. As this is a car and we care for it, I further added some padding to this increased obstacle size to prevent cases of near miss and have some buffer space. But my work did not end here as there was one more problem to be solved. We can reach a position  at time  with multiple possible velocity. Some of them might be so high that even if we apply maximum deceleration, we could not prevent it from crashing in (call this area as area of imminent collision). So, every obstacle vehicle was given with extra padding, given by  (e.g. we will need a padding of  if . In this way, we are better able to sample those points which are feasible. Further, I had to control the size of padding, because as I increased the padding, completeness of my algorithm decreased.
⇒	Number of Samples: Running time of my algorithm was directly impacted by number of samples drawn. As number of samples increased, completeness and optimality of the algorithm increased. Due to much more samples available, algorithm could find a path if it exists with more probability of success or could focus more on finding a better path than current best. I used around 5,000 samples per data and it returned the shortest possible path almost every time.
